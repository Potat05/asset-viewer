var le=Object.defineProperty;var ce=(i,n,t)=>n in i?le(i,n,{enumerable:!0,configurable:!0,writable:!0,value:t}):i[n]=t;var v=(i,n,t)=>(ce(i,typeof n!="symbol"?n+"":n,t),t);import{f as A,a as I}from"./2.1e08a865.js";import{o as $,s as F,e as K,T as de}from"./ThreeUtils.924a2b70.js";import{T as he}from"./TypeUtils.a4045db2.js";import{B as fe}from"./BlobReader.433f7ad9.js";import{r as me,d as pe,a as ge}from"./zip.e039a8dc.js";import{V as U,S as be,B as Y,b as we,c as ye,F as j,M as xe,d as Ne,G as Ee}from"./three.module.501e9167.js";import{V as ve}from"./vtf.116428a1.js";function q(i,n){const t=new DataView(i),e=t.getUint32(4,!0);if(e!=n)throw new Error("BSP decompressing lzma size does not match.");if(t.getUint32(8,!0)+17>i.byteLength)throw new Error("BSP decompressing lzma size does not match.");const c=pe(i.slice(12)),r=ge(i.slice(17),c,e);if(e!=r.byteLength)throw new Error("BSP decompressing lzma size does not match.");return r}class J extends fe{constructor(t){super(t);v(this,"version",-1);v(this,"lumpDirEntries",[]);v(this,"revision",-1)}readLumpDirEntry(){return{offset:this.readNumber("Int32"),length:this.readNumber("Int32"),version:this.readNumber("Int32"),uncompressedLength:this.readNumber("Int32")}}async readHeader(){await this.load(8+32*64+4),this.assertMagic("VBSP"),this.version=this.readNumber("Uint32"),this.lumpDirEntries=this.readArray(this.readLumpDirEntry,64),this.revision=this.readNumber("Uint32")}lumpExists(t){if(t<0||t>=64)return!1;const e=this.lumpDirEntries[t];return e.length!=0||e.offset!=0}async getRawLumpBuffer(t){if(!this.lumpExists(t))return null;const e=this.lumpDirEntries[t],l=await this.blob.slice(e.offset,e.offset+e.length).arrayBuffer();return e.uncompressedLength===0?l:q(l,e.uncompressedLength)}async getRawLumpBlob(t){const e=this.lumpDirEntries[t];if(!e||e.length==0||e.offset==0)return null;const l=this.blob.slice(e.offset,e.offset+e.length);return e.uncompressedLength==0?l:new Blob([q(await l.arrayBuffer(),e.uncompressedLength)])}async loadLump(t){const e=await this.getRawLumpBuffer(t);this.loadData(e??new ArrayBuffer(0))}async getPakFile(t,e){const l=await this.getRawLumpBlob(40);return l==null?null:await me(l,t,e,!0)}readVector(){return new U(this.readNumber("Float32"),this.readNumber("Float32"),this.readNumber("Float32"))}async getVertices(){return await this.loadLump(3),this.readArrayUntilEnd(this.readVector)}async getEdges(){return await this.loadLump(12),this.readArrayUntilEnd(()=>[this.readNumber("Uint16"),this.readNumber("Uint16")])}async getSurfEdges(){return await this.loadLump(13),this.readArrayUntilEnd(this.readNumber,"Int32")}async getFaces(){return await this.loadLump(7),this.readArrayUntilEnd(()=>({planeNum:this.readNumber("Uint16"),side:this.readNumber("Uint8"),onNode:this.readNumber("Uint8")==1,firstEdge:this.readNumber("Uint32"),numEdges:this.readNumber("Uint16"),texInfo:this.readNumber("Uint16"),dispInfo:this.readNumber("Int16"),surfaceFogVolumeID:this.readNumber("Uint16"),styles:[this.readNumber("Uint8"),this.readNumber("Uint8"),this.readNumber("Uint8"),this.readNumber("Uint8")],lightOffsets:this.readNumber("Uint32"),area:this.readNumber("Float32"),lightmapTextureMins:[this.readNumber("Int32"),this.readNumber("Int32")],lightmapTextureSize:[this.readNumber("Int32"),this.readNumber("Int32")],originalFace:this.readNumber("Uint32"),numPrimitives:this.readNumber("Uint16"),firstPrimitiveID:this.readNumber("Uint16"),smoothingGroups:this.readNumber("Uint32")}))}readDispSubEdgeNeighbor(){return{neighbor:this.readNumber("Uint16"),neighborOrientation:this.readNumber("Uint8"),span:this.readNumber("Uint8"),neighborSpan:this.readNumber("Uint8")}}readDispEdgeNeighbor(){return[this.readDispSubEdgeNeighbor(),this.readDispSubEdgeNeighbor()]}readDispCornerNeighbor(){return{neighbors:[this.readNumber("Int16"),this.readNumber("Int16"),this.readNumber("Int16"),this.readNumber("Int16")],numNeighbors:this.readNumber("Uint8")}}async getDispInfos(){return await this.loadLump(26),this.readArrayUntilEnd(()=>({startPosition:this.readVector(),dispVertStart:this.readNumber("Uint32"),dispTriStart:this.readNumber("Uint32"),power:this.readNumber("Uint32"),minTesselation:this.readNumber("Uint32"),smoothingAngle:this.readNumber("Float32"),contents:this.readNumber("Uint32"),mapFace:this.readNumber("Uint16"),lightmapAlphaStart:this.readNumber("Uint32"),lightmapSamplePositionStart:this.readNumber("Uint32"),edgeNeighbors:[this.readDispEdgeNeighbor(),this.readDispEdgeNeighbor(),this.readDispEdgeNeighbor(),this.readDispEdgeNeighbor()],cornerNeighbors:[this.readDispCornerNeighbor(),this.readDispCornerNeighbor(),this.readDispCornerNeighbor(),this.readDispCornerNeighbor()],allowedVerts:this.readBuffer(54)}))}async getDispVerts(){return await this.loadLump(33),this.readArrayUntilEnd(()=>({vec:this.readVector(),dist:this.readNumber("Float32"),alpha:this.readNumber("Float32")}))}readTextureVecs(){return[[this.readNumber("Float32"),this.readNumber("Float32"),this.readNumber("Float32"),this.readNumber("Float32")],[this.readNumber("Float32"),this.readNumber("Float32"),this.readNumber("Float32"),this.readNumber("Float32")]]}async getTexInfos(){return await this.loadLump(6),this.readArrayUntilEnd(()=>({textureVecs:this.readTextureVecs(),lightmapVecs:this.readTextureVecs(),flags:this.readNumber("Uint32"),texData:this.readNumber("Int32")}))}async getTexDatas(){return await this.loadLump(2),this.readArrayUntilEnd(()=>({reflectivity:this.readVector(),nameStringTableID:this.readNumber("Uint32"),width:this.readNumber("Uint32"),height:this.readNumber("Uint32"),view_width:this.readNumber("Uint32"),view_height:this.readNumber("Uint32")}))}async getTexDataStrings(){await this.loadLump(44);const t=this.readArrayUntilEnd(this.readNumber,"Uint32");return await this.loadLump(43),t.map(e=>(this.pointer=e,this.readNullString()))}}class Te{constructor(n,t,e){v(this,"viewer",null);v(this,"type",A.Directory);v(this,"name");v(this,"parent");v(this,"dirs");this.dirs=n,this.name=t,this.parent=e}async list(){let n={};for(const t of this.dirs){const e=await t.list();for(const[l,c]of Object.entries(e))n[l]||(n[l]=c)}return n}async get(n){for(const t of this.dirs){const e=await t.get(n);if(e)return e}return null}set(n,t){throw new Error("Cannot set on merged directory.")}}async function Ue(i,n=[]){if(i.name!="Team Fortress 2")throw new Error("Team Fortress 2 is the only supported source engine game for now.");let t=[...n];const e=["tf","tf/tf2_misc_dir.vpk","tf/tf2_sound_dir.vpk","tf/tf2_textures_dir.vpk"];for(const l of e){const c=await i.get(l);c==null||c.type!=A.Directory||t.push(c)}return new Te(t,i.name,null)}var P;(i=>{function n(r){let d=[],o=0,h=0,s=0;const u=a=>{const m={line:o,column:h,index:s};for(;a>0;)s++,h++,r[s]==`
`&&(o++,h=0),a--;return m},f=a=>{if(a<s)throw new Error("Tokenizer goto index is less than current index.");return u(a-s)};for(;s<r.length;)if(/\//.test(r[s])){const a=s,m=r.indexOf(`
`,s+1),N=r.slice(a,m);d.push({type:"comment",comment:N,...f(m+1)})}else if(/"/.test(r[s])){const a=s,m=r.indexOf('"',a+1),N=r.slice(a+1,m);d.push({type:"string",string:N,...f(m+1)})}else if(/[a-zA-Z0-9]/.test(r[s])){const a=d.at(-1),m=!a||a.type=="newline"?" ":`
`,N=s,L=r.indexOf(m,N+1),R=r.slice(N,L);d.push({type:"string",string:R,...f(L+1)})}else/{/.test(r[s])?d.push({type:"openbracket",...u(1)}):/}/.test(r[s])?d.push({type:"closebracket",...u(1)}):/\n/.test(r[s])?d.push({type:"newline",...u(1)}):u(1);return d}function t(r){r=r.filter(o=>o.type!="comment");let d=0;for(const o of r)o.type=="openbracket"&&d++,o.type=="closebracket"&&d--;for(;d>0;d--)r.push({type:"closebracket",line:-1,column:-1,index:-1});for(let o=0;o<r.length-1;o++)r[o].type=="newline"&&r[o+1].type=="newline"&&(r.splice(o,1),o--);for(let o=1;o<r.length;o++)r[o].type=="openbracket"&&r[o-1].type=="newline"&&(r.splice(o-1,1),o--);return r[0].type=="newline"&&r.splice(0,1),r[r.length-1].type=="newline"&&r.splice(r.length-1,1),r}function e(r,d){let o=[{}];for(let h=0;h<r.length;){const s=o.pop();if(s===void 0)throw new Error("parseTokenized empty stack.");const u=r[h++];if(u.type=="closebracket")continue;if(u.type!="string")throw new Error(`Expected key. at Ln ${u.line}, Col ${u.column}`);const f=d?u.string.toLowerCase():u.string,a=r[h++];if(a.type=="openbracket"){const m={};s[f]=m,o.push(s,m);continue}else if(a.type=="string")s[f]=a.string,o.push(s);else throw new Error(`Invalid value. at Ln ${a.line}, Col ${a.column}`)}return o.pop()}function l(r,d={}){const o=d.lowerKeys??!0,h=d.validator;r=r.replace(/\r\n/g,`
`),r=r.replace(/\r/g,`
`);let s=n(r);s=t(s),s=s.filter(f=>f.type!="newline");const u=e(s,o);return h?h.parse(u):u}i.parse=l;function c(r){throw new Error("Unimplemented.")}i.stringify=c})(P||(P={}));const Ae=$({shader:F()}),Ve=$({$basetexture:F().default("shadertest/BaseTexture"),$translucent:K(["0","1"]).transform(i=>i=="1").default("0")}),Be=$({$basetexture:F().default("shadertest/BaseTexture"),$translucent:K(["0","1"]).transform(i=>i=="1").default("0")}),Se=$({$basetexture:F().default("shadertest/BaseTexture"),$basetexture2:F().default("shadertest/lightmappedtexture"),$translucent:K(["0","1"]).transform(i=>i=="1").default("0")});async function M(i,n){n=`materials/${n.toLowerCase()}.vtf`;const t=await I.getDeep(i,n);if(!t||t.type!=A.File)throw new Error(`Could not find texture "${n}"`);return new ve(await t.buffer()).getTHREETexture()}async function O(i,n){const t=new I.fsFile_Fetch(`${i}.vert`,null),e=new I.fsFile_Fetch(`${i}.frag`,null),l=await(await t.blob()).text(),c=await(await e.blob()).text();return new be({...n,fragmentShader:c,vertexShader:l})}class De{constructor(n){v(this,"file");v(this,"keyValues");this.file=n}async getKeyValues(){if(this.keyValues!==void 0)return this.keyValues;const n=await(await this.file.blob()).text(),t=P.parse(n,{lowerKeys:!0});if(typeof t!="object"||!t)throw new Error("Failed to parse VMT.");const e=Object.keys(t);if(e.length!=1)throw new Error("Failed to parse VMT.");const l=e[0],c=Object.values(t);if(c.length!=1)throw new Error("Failed to parse VMT.");const r=c[0];if(typeof r!="object"||!r)throw new Error("Failed to parse VMT.");return this.keyValues={shader:l,...r},this.keyValues}async parse(n){return n.parse(await this.getKeyValues())}async getShader(n){const t=(await this.parse(Ae)).shader.toLowerCase();switch(t){case"unlitgeneric":{const e=await this.parse(Be);return O("source-engine/shaders/LightMappedGeneric",{uniforms:{u_basetexture:{value:await M(n,e.$basetexture)}},transparent:e.$translucent})}case"lightmappedgeneric":{const e=await this.parse(Ve);return O("source-engine/shaders/LightMappedGeneric",{uniforms:{u_basetexture:{value:await M(n,e.$basetexture)}},transparent:e.$translucent})}case"worldvertextransition":{const e=await this.parse(Se);return O("source-engine/shaders/WorldVertexTransition",{uniforms:{u_basetexture1:{value:await M(n,e.$basetexture)},u_basetexture2:{value:await M(n,e.$basetexture2)}},transparent:e.$translucent})}default:throw new Error(`Unimplemented shader "${t}"`)}}}function Ie(i,n=!1){const t=i[0].index!==null,e=new Set(Object.keys(i[0].attributes)),l=new Set(Object.keys(i[0].morphAttributes)),c={},r={},d=i[0].morphTargetsRelative,o=new Y;let h=0;for(let s=0;s<i.length;++s){const u=i[s];let f=0;if(t!==(u.index!==null))return console.error("THREE.BufferGeometryUtils: .mergeGeometries() failed with geometry at index "+s+". All geometries must have compatible attributes; make sure index attribute exists among all geometries, or in none of them."),null;for(const a in u.attributes){if(!e.has(a))return console.error("THREE.BufferGeometryUtils: .mergeGeometries() failed with geometry at index "+s+'. All geometries must have compatible attributes; make sure "'+a+'" attribute exists among all geometries, or in none of them.'),null;c[a]===void 0&&(c[a]=[]),c[a].push(u.attributes[a]),f++}if(f!==e.size)return console.error("THREE.BufferGeometryUtils: .mergeGeometries() failed with geometry at index "+s+". Make sure all geometries have the same number of attributes."),null;if(d!==u.morphTargetsRelative)return console.error("THREE.BufferGeometryUtils: .mergeGeometries() failed with geometry at index "+s+". .morphTargetsRelative must be consistent throughout all geometries."),null;for(const a in u.morphAttributes){if(!l.has(a))return console.error("THREE.BufferGeometryUtils: .mergeGeometries() failed with geometry at index "+s+".  .morphAttributes must be consistent throughout all geometries."),null;r[a]===void 0&&(r[a]=[]),r[a].push(u.morphAttributes[a])}if(n){let a;if(t)a=u.index.count;else if(u.attributes.position!==void 0)a=u.attributes.position.count;else return console.error("THREE.BufferGeometryUtils: .mergeGeometries() failed with geometry at index "+s+". The geometry must have either an index or a position attribute"),null;o.addGroup(h,a,s),h+=a}}if(t){let s=0;const u=[];for(let f=0;f<i.length;++f){const a=i[f].index;for(let m=0;m<a.count;++m)u.push(a.getX(m)+s);s+=i[f].attributes.position.count}o.setIndex(u)}for(const s in c){const u=Q(c[s]);if(!u)return console.error("THREE.BufferGeometryUtils: .mergeGeometries() failed while trying to merge the "+s+" attribute."),null;o.setAttribute(s,u)}for(const s in r){const u=r[s][0].length;if(u===0)break;o.morphAttributes=o.morphAttributes||{},o.morphAttributes[s]=[];for(let f=0;f<u;++f){const a=[];for(let N=0;N<r[s].length;++N)a.push(r[s][N][f]);const m=Q(a);if(!m)return console.error("THREE.BufferGeometryUtils: .mergeGeometries() failed while trying to merge the "+s+" morphAttribute."),null;o.morphAttributes[s].push(m)}}return o}function Q(i){let n,t,e,l=-1,c=0;for(let h=0;h<i.length;++h){const s=i[h];if(s.isInterleavedBufferAttribute)return console.error("THREE.BufferGeometryUtils: .mergeAttributes() failed. InterleavedBufferAttributes are not supported."),null;if(n===void 0&&(n=s.array.constructor),n!==s.array.constructor)return console.error("THREE.BufferGeometryUtils: .mergeAttributes() failed. BufferAttribute.array must be of consistent array types across matching attributes."),null;if(t===void 0&&(t=s.itemSize),t!==s.itemSize)return console.error("THREE.BufferGeometryUtils: .mergeAttributes() failed. BufferAttribute.itemSize must be consistent across matching attributes."),null;if(e===void 0&&(e=s.normalized),e!==s.normalized)return console.error("THREE.BufferGeometryUtils: .mergeAttributes() failed. BufferAttribute.normalized must be consistent across matching attributes."),null;if(l===-1&&(l=s.gpuType),l!==s.gpuType)return console.error("THREE.BufferGeometryUtils: .mergeAttributes() failed. BufferAttribute.gpuType must be consistent across matching attributes."),null;c+=s.array.length}const r=new n(c);let d=0;for(let h=0;h<i.length;++h)r.set(i[h].array,d),d+=i[h].array.length;const o=new we(r,t,e);return l!==void 0&&(o.gpuType=l),o}const Ce={namespace:"source-engine.bsp",priority:2,createViewer:async(i,n)=>{if(i.type==A.Directory){const t=i.old;if(!t||t.type==A.Directory)throw new Error("Tried to create bsp viewer with transformed viewer that has no file.");const e=new J(await t.blob());await e.readHeader();const l=I.root(i),c=l&&l!=i?await Ue(l,[i]):i,{renderer:r,scene:d}=de.createRendererWithControls(),o=r.domElement;o.style.width="100vw",o.style.height="100vh",n.appendChild(o);const h=await e.getVertices(),s=await e.getEdges(),u=await e.getSurfEdges(),f=await e.getFaces(),a=await e.getTexInfos(),m=await e.getTexDatas(),N=await e.getDispInfos(),L=await e.getDispVerts(),R=await e.getTexDataStrings(),W=await Promise.all(R.map(async g=>{g=`materials/${g.toLowerCase()}`,g.endsWith(".vmt")||(g+=".vmt");const b=await I.getDeep(c,g);if(!b||b.type!=A.File)return console.warn(`Could not find material file "${g}"`),null;const T=new De(b);try{return await T.getShader(c)}catch(B){return console.error(B),console.warn(`Failed to get shader "${g}"`),null}}));console.log(c);const Z=W.map(()=>[]);for(const g of f){const b=a[g.texInfo],T=m[b.texData],B=T.reflectivity;let y=[];for(let p=0;p<g.numEdges;p++){const w=u[g.firstEdge+p],V=s[Math.abs(w)],H=h[V[w<0?1:0]];y.push(H)}let C=[];if(g.dispInfo==-1)for(let p=0;p<y.length-2;p++)C.push(p+2,p+1,0);else{if(y.length!=4)throw new Error("BSP Invalid displacement.");const p=N[g.dispInfo],w=Math.pow(2,p.power),V=y.findIndex(x=>p.startPosition.distanceTo(x)<.1),H=y[(V+0)%4],ae=y[(V+1)%4],oe=y[(V+2)%4],ue=y[(V+3)%4];y=[];for(let x=0;x<w+1;x++)for(let E=0;E<w+1;E++){const D=x/w,_=E/w,G=x*(w+1)+E,z=L[p.dispVertStart+G],X=new U().lerpVectors(new U().lerpVectors(H,ae,D),new U().lerpVectors(ue,oe,D),_);X.add(new U().copy(z.vec).multiplyScalar(z.dist)),y.push(X)}for(let x=0;x<w;x++)for(let E=0;E<w;E++){const D=x*(w+1)+E,_=(x+1)*(w+1)+E,G=(x+1)*(w+1)+E+1,z=x*(w+1)+E+1;C.push(G,_,D,z,G,D)}}const te=new U(b.textureVecs[0][0],b.textureVecs[0][1],b.textureVecs[0][2]),re=new U(b.textureVecs[1][0],b.textureVecs[1][1],b.textureVecs[1][2]),se=b.textureVecs[0][3],ie=b.textureVecs[1][3],ne=y.map(p=>new ye((te.dot(p)+se)/T.width,(re.dot(p)+ie)/T.height)),S=new Y;S.setAttribute("position",new j(y.map(p=>p.toArray()).flat(),3)),S.setAttribute("color",new j(y.map(()=>B.toArray()).flat(),3)),S.setIndex(C),S.setAttribute("uv",new j(ne.map(p=>p.toArray()).flat(),2)),Z[T.nameStringTableID].push(S)}const ee=Z.map((g,b)=>{if(g.length==0)return null;const T=W[b],B=Ie(g);return new xe(B,T??new Ne({vertexColors:!0}))}).filter(he.isNotNull),k=new Ee;k.add(...ee),k.rotateX(-Math.PI/2),d.add(k)}else throw new Error("Tried to create bsp viewer with file.")},transform:async i=>{if(i.type!=A.File)throw new Error("Tried to create bsp pakfile archive viewer with invalid entry type.");const n=new J(await i.blob());await n.readHeader();const t=await n.getPakFile(i.name,i.parent);if(!t)return null;const e=t;return e.old=i,e},getIcon:async()=>"/asset-viewer/bootstrap-icons/boxes.svg"};export{Ce as default};
