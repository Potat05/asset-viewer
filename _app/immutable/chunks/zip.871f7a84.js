var v=Object.defineProperty;var _=(i,t,r)=>t in i?v(i,t,{enumerable:!0,configurable:!0,writable:!0,value:r}):i[t]=r;var a=(i,t,r)=>(_(i,typeof t!="symbol"?t+"":t,r),r);import{B as L}from"./BlobReader.86937414.js";import{U as y,f as P,a as z,N as k,D as A}from"./2.2ee3d51f.js";import{i as R}from"./pako.esm.29d98458.js";class E{constructor(t){a(this,"data");a(this,"pos");this.data=new Uint8Array(y.getBuffer(t)),this.pos=0}readByte(){return this.data[this.pos++]}}class Z{constructor(t,r){a(this,"windowBuffer");a(this,"pos",0);a(this,"streamPos",0);a(this,"outputPos",0);this.windowSize=t,this.outputBuffer=r,this.windowBuffer=new Uint8Array(this.windowSize)}flush(){let t=this.pos-this.streamPos;t!==0&&(this.outputBuffer.set(this.windowBuffer.subarray(0,t),this.outputPos),this.outputPos+=t,this.pos>=this.windowSize&&(this.pos=0),this.streamPos=this.pos)}copyBlock(t,r){let s=this.pos-t-1;for(s<0&&(s+=this.windowSize);r--;)s>=this.windowSize&&(s=0),this.windowBuffer[this.pos++]=this.windowBuffer[s++],this.pos>=this.windowSize&&this.flush()}putByte(t){this.windowBuffer[this.pos++]=t,this.pos>=this.windowSize&&this.flush()}getByte(t){let r=this.pos-t-1;return r<0&&(r+=this.windowSize),this.windowBuffer[r]}}class I{constructor(t){a(this,"code",0);a(this,"range",-1);this.stream=t;for(let r=0;r<5;r++)this.code=this.code<<8|this.stream.readByte()}decodeDirectBits(t){var r=0,s;for(let e=0;e<t;e++)this.range>>>=1,s=this.code-this.range>>>31,this.code-=this.range&s-1,r=r<<1|1-s,this.range&4278190080||(this.code=this.code<<8|this.stream.readByte(),this.range<<=8);return r}decodeBit(t,r){var s=t[r],e=(this.range>>>11)*s;return(this.code^2147483648)<(e^2147483648)?(this.range=e,t[r]+=2048-s>>>5,this.range&4278190080||(this.code=this.code<<8|this.stream.readByte(),this.range<<=8),0):(this.range-=e,this.code-=e,t[r]-=s>>>5,this.range&4278190080||(this.code=this.code<<8|this.stream.readByte(),this.range<<=8),1)}}function w(i){return y.initArray(i,()=>1024)}class N{constructor(t){a(this,"models");this.numBitLevels=t,this.models=w(1<<this.numBitLevels)}decode(t){for(var r=1,s=this.numBitLevels;s--;)r=r<<1|t.decodeBit(this.models,r);return r-(1<<this.numBitLevels)}reverseDecode(t){for(var r=1,s=0,e=0,n;e<this.numBitLevels;++e)n=t.decodeBit(this.models,r),r=r<<1|n,s|=n<<e;return s}}function x(i,t,r,s){for(var e=1,n=0,d=0,o;d<s;++d)o=r.decodeBit(i,t+e),e=e<<1|o,n|=o<<d;return n}class D{constructor(t){a(this,"choice",w(2));a(this,"lowCoder");a(this,"midCoder");a(this,"highCoder",new N(8));this.numPosStates=t,this.lowCoder=y.initArray(this.numPosStates,()=>new N(3)),this.midCoder=y.initArray(this.numPosStates,()=>new N(3))}decode(t,r){return t.decodeBit(this.choice,0)===0?this.lowCoder[r].decode(t):t.decodeBit(this.choice,1)===0?8+this.midCoder[r].decode(t):16+this.highCoder.decode(t)}}class T{constructor(){a(this,"decoders",w(768))}decodeNormal(t){let r=1;do r=r<<1|t.decodeBit(this.decoders,r);while(r<256);return r&255}decodeWithMatchByte(t,r){let s=1,e,n;do if(e=r>>7&1,r<<=1,n=t.decodeBit(this.decoders,(1+e<<8)+s),s=s<<1|n,e!==n){for(;s<256;)s=s<<1|t.decodeBit(this.decoders,s);break}while(s<256);return s&255}}class F{constructor(t,r){a(this,"posMask",0);a(this,"coders");this.numPosBits=t,this.numPrevBits=r,this.posMask=(1<<this.numPosBits)-1;const s=1<<this.numPrevBits+this.numPosBits;this.coders=y.initArray(s,()=>new T)}getDecoder(t,r){return this.coders[((t&this.posMask)<<this.numPrevBits)+((r&255)>>>8-this.numPrevBits)]}}class G{constructor(t){a(this,"isMatchDecoders",w(192));a(this,"isRep0LongDecoders",w(192));a(this,"isRepDecoders",w(12));a(this,"isRepG0Decoders",w(12));a(this,"isRepG1Decoders",w(12));a(this,"isRepG2Decoders",w(12));a(this,"posDecoders",w(114));a(this,"posSlotDecoder",y.initArray(4,()=>new N(6)));a(this,"posAlignDecoder",new N(4));a(this,"lenDecoder");a(this,"repLenDecoder");a(this,"literalDecoder");a(this,"dictionarySize",-1);a(this,"dictionarySizeCheck",-1);a(this,"posStateMask",0);if(this.dictionarySize=t.dictionarySize,this.dictionarySize==0)throw new Error("LZMA decoder initialized with invalid dictionary size.");this.dictionarySizeCheck=Math.max(this.dictionarySize,1);const r=t.lc,s=t.lp,e=t.pb,n=1<<e;if(!(r<=8&&s<=4&&e<=4))throw new Error("LZMA decoder initialized with invalid properties.");this.literalDecoder=new F(s,r),this.lenDecoder=new D(n),this.repLenDecoder=new D(n),this.posStateMask=n-1}decodeBody(t,r,s){let e=0,n=0,d=0,o=0,c=0,l=0,u=0,m,B,f,p,b,U;const h=new I(t);if(r.byteLength<s)throw new Error("LZMA decoder read body with invalid size.");const g=new Z(Math.max(this.dictionarySizeCheck,4096),r);for(;s<0||l<s;)if(m=l&this.posStateMask,h.decodeBit(this.isMatchDecoders,(e<<4)+m)===0)B=this.literalDecoder.getDecoder(l++,u),e>=7?u=B.decodeWithMatchByte(h,g.getByte(n)):u=B.decodeNormal(h),g.putByte(u),e=e<4?0:e-(e<10?3:6);else{if(h.decodeBit(this.isRepDecoders,e)===1)f=0,h.decodeBit(this.isRepG0Decoders,e)===0?h.decodeBit(this.isRep0LongDecoders,(e<<4)+m)===0&&(e=e<7?9:11,f=1):(h.decodeBit(this.isRepG1Decoders,e)===0?p=d:(h.decodeBit(this.isRepG2Decoders,e)===0?p=o:(p=c,c=o),o=d),d=n,n=p),f===0&&(f=2+this.repLenDecoder.decode(h,m),e=e<7?8:11);else if(c=o,o=d,d=n,f=2+this.lenDecoder.decode(h,m),e=e<7?7:10,b=this.posSlotDecoder[f<=5?f-2:3].decode(h),b>=4){if(U=(b>>1)-1,n=(2|b&1)<<U,b<14)n+=x(this.posDecoders,n-b-1,h,U);else if(n+=h.decodeDirectBits(U-4)<<4,n+=this.posAlignDecoder.reverseDecode(h),n<0){if(n===-1)break;return!1}}else n=b;if(n>=l||n>=this.dictionarySizeCheck)return!1;g.copyBlock(n,f),l+=f,u=g.getByte(0)}return g.flush(),!0}}function O(i){const t=new DataView(y.getBuffer(i));let r=t.getUint8(0);const s=r%9;r=~~(r/9);const e=r%5,n=~~(r/5),d=t.getUint32(1,!0);return{lc:s,lp:e,pb:n,dictionarySize:d}}function $(i,t,r){const s=new E(i),e=new Uint8Array(r);if(!new G(t).decodeBody(s,e,r))throw new Error("LZMA failed decompressing.");return e.buffer}var M=(i=>(i[i.none=0]="none",i[i.shrunk=1]="shrunk",i[i.reduced_1=2]="reduced_1",i[i.reduced_2=3]="reduced_2",i[i.reduced_3=4]="reduced_3",i[i.reduced_4=5]="reduced_4",i[i.imploded=6]="imploded",i[i.deflated=8]="deflated",i[i.enhanced_deflated=9]="enhanced_deflated",i[i.pkware_dcl_imploded=10]="pkware_dcl_imploded",i[i.bzip2=12]="bzip2",i[i.lzma=14]="lzma",i[i.ibm_terse=18]="ibm_terse",i[i.ibm_lz77_z=19]="ibm_lz77_z",i[i.zstandard=93]="zstandard",i[i.mp3=94]="mp3",i[i.xz=95]="xz",i[i.jpeg=96]="jpeg",i[i.wavpack=97]="wavpack",i[i.ppmd=98]="ppmd",i[i.aex_encryption_marker=99]="aex_encryption_marker",i))(M||{});class S{constructor(t,r,s,e=null){a(this,"viewer",null);a(this,"type",P.File);a(this,"name");a(this,"parent");a(this,"zip");a(this,"options");a(this,"loadedBlob",null);this.zip=t,this.options=r,this.name=s,this.parent=e}async blob(){if(this.loadedBlob!=null)return this.loadedBlob;let t,r,s,e;if(this.options.type=="fileheader")t=this.options.compressionMethod,r=this.options.offset,s=this.options.compressedSize,e=this.options.uncompressedSize;else if(this.options.type=="centralfileheader"){const d=new L(this.zip);await d.load(30,this.options.offsetToLocalHeader),d.assertMagic("PK"),d.assertMagic(1027,"Uint16"),d.readNumber("Uint16"),d.readNumber("Uint16"),t=d.readNumber("Uint16"),d.readNumber("Uint32"),d.readNumber("Uint32"),s=d.readNumber("Uint32"),e=d.readNumber("Uint32");const o=d.readNumber("Uint16"),c=d.readNumber("Uint16");await d.load(o+c),d.readString(o,"utf-8"),d.readBuffer(c),r=d.blobPointer}else throw new Error("Zip file invalid options.");t!=0&&console.debug(`Decompressing file ${this.name} with ${M[t]??k.hex(t,2)} compression method`);const n=this.zip.slice(r,r+s);switch(t){case 0:{this.loadedBlob=n;break}case 8:{const d=await n.arrayBuffer(),o=R(d);this.loadedBlob=new Blob([o]);break}case 14:{const d=await n.arrayBuffer(),o=new A(d);o.readNumber("Uint8"),o.readNumber("Uint8");const c=o.readNumber("Uint16"),l=o.readBuffer(c),u=$(o.readBuffer(o.dataLeft),O(l),e);this.loadedBlob=new Blob([u]);break}default:throw new Error("Unknown zip file compression method.")}if(this.loadedBlob==null)throw new Error("Could not decompress zip file.");return this.loadedBlob}async buffer(){return await(await this.blob()).arrayBuffer()}}async function K(i){const s=[{start:Math.max(0,i.size-128),end:i.size},{start:Math.max(0,i.size-65558),end:i.size}],e=19280|1541<<16;for(const n of s){const d=i.slice(n.start,n.end),o=new DataView(await d.arrayBuffer());for(let c=o.byteLength-4;c>0;c--)if(o.getUint32(c,!0)==e)return i.size-(n.end-n.start)+c}return-1}async function X(){const i=arguments[0];let t=arguments[1],r=arguments[2],s;i.type==P.File?(s=await i.blob(),t=i.name,r=i.parent):(s=i,t=t);const e=new L(s),n=new z.fsDirectory_Container(t,r),d=await K(s);if(d==-1)for(console.warn("Reading ZIP file without central directory.");!e.blobEof;){if(await e.load(4),!e.magic("PK"))return console.warn(`Invalid ZIP section type header. at ${e.blobPointer-2}`),n;const o=e.readNumber("Uint16");switch(o){case 513:{await e.load(42),e.readNumber("Uint16"),e.readNumber("Uint16"),e.readNumber("Uint16"),e.readNumber("Uint16"),e.readNumber("Uint32"),e.readNumber("Uint32"),e.readNumber("Uint32"),e.readNumber("Uint32");const c=e.readNumber("Uint16"),l=e.readNumber("Uint16"),u=e.readNumber("Uint16");e.readNumber("Uint16"),e.readNumber("Uint16"),e.readNumber("Uint32"),e.readNumber("Uint32"),await e.load(c+l+u),e.readString(c,"utf-8"),e.readBuffer(l),e.readString(u,"utf-8");break}case 1027:{await e.load(26),e.readNumber("Uint16"),e.readNumber("Uint16");const c=e.readNumber("Uint16");e.readNumber("Uint32"),e.readNumber("Uint32");const l=e.readNumber("Uint32"),u=e.readNumber("Uint32"),m=e.readNumber("Uint16"),B=e.readNumber("Uint16");await e.load(m+B);const f=e.readString(m,"utf-8");e.readBuffer(B),e.blobPointer;const p=f.split("/").pop();if(p==null)throw new Error("Failed to read filename in zip file.");if(l>0){const b=new S(s,{type:"fileheader",compressionMethod:c,offset:e.blobPointer,compressedSize:l,uncompressedSize:u},p);await z.setDeep(n,f,b)}e.blobPointer+=l;break}case 2055:{e.blobPointer+=12;break}case 1541:return n;default:return console.warn(`Invalid ZIP section type. ${o} at ${e.blobPointer-2}`),n}}else{await e.load(22,d),e.assertMagic("PK"),e.assertMagic(1541,"Uint16"),e.readNumber("Uint16"),e.readNumber("Uint16"),e.readNumber("Uint16"),e.readNumber("Uint16");const o=e.readNumber("Uint32"),c=e.readNumber("Uint32"),l=e.readNumber("Uint16");for(await e.load(l),e.readString(e.dataLeft),await e.load(o,c);!e.eof;){e.assertMagic("PK"),e.assertMagic(513,"Uint16"),e.readNumber("Uint16"),e.readNumber("Uint16"),e.readNumber("Uint16"),e.readNumber("Uint16"),e.readNumber("Uint32"),e.readNumber("Uint32");const u=e.readNumber("Uint32");e.readNumber("Uint32");const m=e.readNumber("Uint16"),B=e.readNumber("Uint16"),f=e.readNumber("Uint16");e.readNumber("Uint16"),e.readNumber("Uint16"),e.readNumber("Uint32");const p=e.readNumber("Uint32"),b=e.readString(m,"utf-8");e.readBuffer(B),e.readString(f,"utf-8");const U=b.split("/").pop();if(U==null)throw new Error("Failed to read filename in zip file.");if(u>0){const h=new S(s,{type:"centralfileheader",offsetToLocalHeader:p},U);await z.setDeep(n,b,h)}}}return n}export{$ as a,O as d,X as r};
