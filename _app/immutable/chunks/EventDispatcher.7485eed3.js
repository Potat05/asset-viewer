var d=Object.defineProperty;var f=(n,e,t)=>e in n?d(n,e,{enumerable:!0,configurable:!0,writable:!0,value:t}):n[e]=t;var o=(n,e,t)=>(f(n,typeof e!="symbol"?e+"":e,t),t);let l=0;class h{constructor(){o(this,"destroyed",!1);o(this,"listeners",new Map)}addEventListener(e,t,r=!1){var s;if(this.destroyed)throw new Error("Usage of event dispatcher after being destroyed.");return this.listeners.has(e)||this.listeners.set(e,[]),(s=this.listeners.get(e))==null||s.push({callbackfn:t,once:r,id:l}),l++}removeEventListener(){if(this.destroyed)throw new Error("Usage of event dispatcher after being destroyed.");if(typeof arguments[0]=="number"){for(const e of this.listeners.values())for(let t=0;t<e.length;t++)if(e[t].id==arguments[0])return e.splice(t,1),!0;return!1}else{const e=arguments[0],t=arguments[1],r=arguments[2],s=this.listeners.get(e);if(s===void 0)return!1;for(let i=0;i<s.length;i++){const a=s[i];if(a.callbackfn===t&&a.once===r)return s.splice(i,1),!0}return!1}}dispatchEvent(e,...t){if(this.destroyed)throw new Error("Usage of event dispatcher after being destroyed.");const r=this.listeners.get(e);r!==void 0&&r.forEach(s=>{s.callbackfn(...t),s.once&&this.removeEventListener(e,s.callbackfn,s.once)})}destroyDispatcher(){if(this.destroyed)throw new Error("Usage of event dispatcher after being destroyed.");this.destroyed=!0,this.listeners.forEach((e,t)=>{this.listeners.delete(t)})}}export{h as E};
