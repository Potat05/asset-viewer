var le=Object.defineProperty;var ce=(i,n,t)=>n in i?le(i,n,{enumerable:!0,configurable:!0,writable:!0,value:t}):i[n]=t;var E=(i,n,t)=>(ce(i,typeof n!="symbol"?n+"":n,t),t);import{f as V,a as F}from"./2.d113004e.js";import{o as z,s as I,e as P,T as de}from"./ThreeUtils.924a2b70.js";import{T as he}from"./TypeUtils.a4045db2.js";import{B as fe}from"./BlobReader.cba8113c.js";import{r as me,d as pe,a as ge}from"./zip.98f397b3.js";import{V as U,S as be,B as J,b as we,c as ye,F as H,M as Ne,d as xe,G as Ee}from"./three.module.501e9167.js";import{V as ve}from"./vtf.626953f2.js";function Z(i,n){const t=new DataView(i),e=t.getUint32(4,!0);if(e!=n)throw new Error("BSP decompressing lzma size does not match.");if(t.getUint32(8,!0)+17>i.byteLength)throw new Error("BSP decompressing lzma size does not match.");const c=pe(i.slice(12)),s=ge(i.slice(17),c,e);if(e!=s.byteLength)throw new Error("BSP decompressing lzma size does not match.");return s}class X extends fe{constructor(t){super(t);E(this,"version",-1);E(this,"lumpDirEntries",[]);E(this,"revision",-1)}readLumpDirEntry(){return{offset:this.readNumber("Int32"),length:this.readNumber("Int32"),version:this.readNumber("Int32"),uncompressedLength:this.readNumber("Int32")}}async readHeader(){await this.load(8+32*64+4),this.assertMagic("VBSP"),this.version=this.readNumber("Uint32"),this.lumpDirEntries=this.readArray(this.readLumpDirEntry,64),this.revision=this.readNumber("Uint32")}lumpExists(t){if(t<0||t>=64)return!1;const e=this.lumpDirEntries[t];return e.length!=0||e.offset!=0}async getRawLumpBuffer(t){if(!this.lumpExists(t))return null;const e=this.lumpDirEntries[t],l=await this.blob.slice(e.offset,e.offset+e.length).arrayBuffer();return e.uncompressedLength===0?l:Z(l,e.uncompressedLength)}async getRawLumpBlob(t){const e=this.lumpDirEntries[t];if(!e||e.length==0||e.offset==0)return null;const l=this.blob.slice(e.offset,e.offset+e.length);return e.uncompressedLength==0?l:new Blob([Z(await l.arrayBuffer(),e.uncompressedLength)])}async loadLump(t){const e=await this.getRawLumpBuffer(t);this.loadData(e??new ArrayBuffer(0))}async getPakFile(t,e){const l=await this.getRawLumpBlob(40);return l==null?null:await me(l,t,e,!0)}readVector(){return new U(this.readNumber("Float32"),this.readNumber("Float32"),this.readNumber("Float32"))}async getVertices(){return await this.loadLump(3),this.readArrayUntilEnd(this.readVector)}async getEdges(){return await this.loadLump(12),this.readArrayUntilEnd(()=>[this.readNumber("Uint16"),this.readNumber("Uint16")])}async getSurfEdges(){return await this.loadLump(13),this.readArrayUntilEnd(this.readNumber,"Int32")}async getFaces(){return await this.loadLump(7),this.readArrayUntilEnd(()=>({planeNum:this.readNumber("Uint16"),side:this.readNumber("Uint8"),onNode:this.readNumber("Uint8")==1,firstEdge:this.readNumber("Uint32"),numEdges:this.readNumber("Uint16"),texInfo:this.readNumber("Uint16"),dispInfo:this.readNumber("Int16"),surfaceFogVolumeID:this.readNumber("Uint16"),styles:[this.readNumber("Uint8"),this.readNumber("Uint8"),this.readNumber("Uint8"),this.readNumber("Uint8")],lightOffsets:this.readNumber("Uint32"),area:this.readNumber("Float32"),lightmapTextureMins:[this.readNumber("Int32"),this.readNumber("Int32")],lightmapTextureSize:[this.readNumber("Int32"),this.readNumber("Int32")],originalFace:this.readNumber("Uint32"),numPrimitives:this.readNumber("Uint16"),firstPrimitiveID:this.readNumber("Uint16"),smoothingGroups:this.readNumber("Uint32")}))}readDispSubEdgeNeighbor(){return{neighbor:this.readNumber("Uint16"),neighborOrientation:this.readNumber("Uint8"),span:this.readNumber("Uint8"),neighborSpan:this.readNumber("Uint8")}}readDispEdgeNeighbor(){return[this.readDispSubEdgeNeighbor(),this.readDispSubEdgeNeighbor()]}readDispCornerNeighbor(){return{neighbors:[this.readNumber("Int16"),this.readNumber("Int16"),this.readNumber("Int16"),this.readNumber("Int16")],numNeighbors:this.readNumber("Uint8")}}async getDispInfos(){return await this.loadLump(26),this.readArrayUntilEnd(()=>({startPosition:this.readVector(),dispVertStart:this.readNumber("Uint32"),dispTriStart:this.readNumber("Uint32"),power:this.readNumber("Uint32"),minTesselation:this.readNumber("Uint32"),smoothingAngle:this.readNumber("Float32"),contents:this.readNumber("Uint32"),mapFace:this.readNumber("Uint16"),lightmapAlphaStart:this.readNumber("Uint32"),lightmapSamplePositionStart:this.readNumber("Uint32"),edgeNeighbors:[this.readDispEdgeNeighbor(),this.readDispEdgeNeighbor(),this.readDispEdgeNeighbor(),this.readDispEdgeNeighbor()],cornerNeighbors:[this.readDispCornerNeighbor(),this.readDispCornerNeighbor(),this.readDispCornerNeighbor(),this.readDispCornerNeighbor()],allowedVerts:this.readBuffer(54)}))}async getDispVerts(){return await this.loadLump(33),this.readArrayUntilEnd(()=>({vec:this.readVector(),dist:this.readNumber("Float32"),alpha:this.readNumber("Float32")}))}readTextureVecs(){return[[this.readNumber("Float32"),this.readNumber("Float32"),this.readNumber("Float32"),this.readNumber("Float32")],[this.readNumber("Float32"),this.readNumber("Float32"),this.readNumber("Float32"),this.readNumber("Float32")]]}async getTexInfos(){return await this.loadLump(6),this.readArrayUntilEnd(()=>({textureVecs:this.readTextureVecs(),lightmapVecs:this.readTextureVecs(),flags:this.readNumber("Uint32"),texData:this.readNumber("Int32")}))}async getTexDatas(){return await this.loadLump(2),this.readArrayUntilEnd(()=>({reflectivity:this.readVector(),nameStringTableID:this.readNumber("Uint32"),width:this.readNumber("Uint32"),height:this.readNumber("Uint32"),view_width:this.readNumber("Uint32"),view_height:this.readNumber("Uint32")}))}async getTexDataStrings(){await this.loadLump(44);const t=this.readArrayUntilEnd(this.readNumber,"Uint32");return await this.loadLump(43),t.map(e=>(this.pointer=e,this.readNullString()))}}class Te{constructor(n,t,e){E(this,"viewer",null);E(this,"type",V.Directory);E(this,"name");E(this,"parent");E(this,"dirs");this.dirs=n,this.name=t,this.parent=e}async list(){let n={};for(const t of this.dirs){const e=await t.list();for(const[l,c]of Object.entries(e))n[l]||(n[l]=c)}return n}async get(n){for(const t of this.dirs){const e=await t.get(n);if(e)return e}return null}set(n,t){throw new Error("Cannot set on merged directory.")}}async function Ue(i,n=[]){if(i.name!="Team Fortress 2")throw new Error("Team Fortress 2 is the only supported source engine game for now.");let t=[...n];const e=["tf","tf/tf2_misc_dir.vpk","tf/tf2_sound_dir.vpk","tf/tf2_textures_dir.vpk"];for(const l of e){const c=await i.get(l);c==null||c.type!=V.Directory||t.push(c)}return new Te(t,i.name,null)}var j;(i=>{function n(s){let d=[],o=0,h=0,r=0;const u=a=>{const p={line:o,column:h,index:r};for(;a>0;)r++,h++,s[r]==`
`&&(o++,h=0),a--;return p},f=a=>{if(a<r)throw new Error("Tokenizer goto index is less than current index.");return u(a-r)};for(;r<s.length;)if(/\//.test(s[r])){const a=r,p=s.indexOf(`
`,r+1),v=s.slice(a,p);d.push({type:"comment",comment:v,...f(p+1)})}else if(/"/.test(s[r])){const a=r,p=s.indexOf('"',a+1),v=s.slice(a+1,p);d.push({type:"string",string:v,...f(p+1)})}else/{/.test(s[r])?d.push({type:"openbracket",...u(1)}):/}/.test(s[r])?d.push({type:"closebracket",...u(1)}):/\n/.test(s[r])?d.push({type:"newline",...u(1)}):u(1);return d}function t(s){s=s.filter(o=>o.type!="comment");let d=0;for(const o of s)o.type=="openbracket"&&d++,o.type=="closebracket"&&d--;for(;d>0;d--)s.push({type:"closebracket",line:-1,column:-1,index:-1});for(let o=0;o<s.length-1;o++)s[o].type=="newline"&&s[o+1].type=="newline"&&(s.splice(o,1),o--);for(let o=1;o<s.length;o++)s[o].type=="openbracket"&&s[o-1].type=="newline"&&(s.splice(o-1,1),o--);return s[0].type=="newline"&&s.splice(0,1),s[s.length-1].type=="newline"&&s.splice(s.length-1,1),s}function e(s,d,o){const h=s[d];if(h.type=="string")return{value:h.string,index:d+1};if(h.type=="openbracket"){const u={};for(var r=d+1;r<s.length;r++){const f=s[r];if(f.type=="string"){const a=e(s,r+1,o);u[o?f.string.toLowerCase():f.string]=a.value,r=a.index}else if(f.type=="openbracket")for(let a=r+1;a<s.length;a++)s[a].type=="openbracket",s[a].type=="closebracket";else if(f.type=="closebracket")break}return{value:u,index:r+1}}else throw new Error("Malformed KeyValues tokens.")}function l(s,d={}){const o=d.lowerKeys??!0,h=d.validator;let r=n(s);r=t(r),r=r.filter(p=>p.type!="newline");const u=r[0];if(u.type!="string")throw new Error("Keyvalues first token must be a key.");const f=e(r,1,o),a={[o?u.string.toLowerCase():u.string]:f.value};return h?h.parse(a):a}i.parse=l;function c(s){throw new Error("Unimplemented.")}i.stringify=c})(j||(j={}));const Ve=z({shader:I()}),Ae=z({$basetexture:I().default("shadertest/BaseTexture"),$translucent:P(["0","1"]).transform(i=>i=="1").default("0")}),Be=z({$basetexture:I().default("shadertest/BaseTexture"),$translucent:P(["0","1"]).transform(i=>i=="1").default("0")}),De=z({$basetexture:I().default("shadertest/BaseTexture"),$basetexture2:I().default("shadertest/lightmappedtexture"),$translucent:P(["0","1"]).transform(i=>i=="1").default("0")});async function M(i,n){n=`materials/${n.toLowerCase()}.vtf`;const t=await F.getDeep(i,n);if(!t||t.type!=V.File)throw new Error(`Could not find texture "${n}"`);return new ve(await t.buffer()).getTHREETexture()}async function _(i,n){const t=new F.fsFile_Fetch(`${i}.vert`,null),e=new F.fsFile_Fetch(`${i}.frag`,null),l=await(await t.blob()).text(),c=await(await e.blob()).text();return new be({...n,fragmentShader:c,vertexShader:l})}class Se{constructor(n){E(this,"file");E(this,"keyValues");this.file=n}async getKeyValues(){if(this.keyValues!==void 0)return this.keyValues;const n=await(await this.file.blob()).text(),t=j.parse(n,{lowerKeys:!0});if(typeof t!="object"||!t)throw new Error("Failed to parse VMT.");const e=Object.keys(t);if(e.length!=1)throw new Error("Failed to parse VMT.");const l=e[0],c=Object.values(t);if(c.length!=1)throw new Error("Failed to parse VMT.");const s=c[0];if(typeof s!="object"||!s)throw new Error("Failed to parse VMT.");return this.keyValues={shader:l,...s},this.keyValues}async parse(n){return n.parse(await this.getKeyValues())}async getShader(n){const t=(await this.parse(Ve)).shader.toLowerCase();switch(t){case"unlitgeneric":{const e=await this.parse(Be);return _("source-engine/shaders/LightMappedGeneric",{uniforms:{u_basetexture:{value:await M(n,e.$basetexture)}},transparent:e.$translucent})}case"lightmappedgeneric":{const e=await this.parse(Ae);return _("source-engine/shaders/LightMappedGeneric",{uniforms:{u_basetexture:{value:await M(n,e.$basetexture)}},transparent:e.$translucent})}case"worldvertextransition":{const e=await this.parse(De);return _("source-engine/shaders/WorldVertexTransition",{uniforms:{u_basetexture1:{value:await M(n,e.$basetexture)},u_basetexture2:{value:await M(n,e.$basetexture2)}},transparent:e.$translucent})}default:throw new Error(`Unimplemented shader "${t}"`)}}}function Fe(i,n=!1){const t=i[0].index!==null,e=new Set(Object.keys(i[0].attributes)),l=new Set(Object.keys(i[0].morphAttributes)),c={},s={},d=i[0].morphTargetsRelative,o=new J;let h=0;for(let r=0;r<i.length;++r){const u=i[r];let f=0;if(t!==(u.index!==null))return console.error("THREE.BufferGeometryUtils: .mergeGeometries() failed with geometry at index "+r+". All geometries must have compatible attributes; make sure index attribute exists among all geometries, or in none of them."),null;for(const a in u.attributes){if(!e.has(a))return console.error("THREE.BufferGeometryUtils: .mergeGeometries() failed with geometry at index "+r+'. All geometries must have compatible attributes; make sure "'+a+'" attribute exists among all geometries, or in none of them.'),null;c[a]===void 0&&(c[a]=[]),c[a].push(u.attributes[a]),f++}if(f!==e.size)return console.error("THREE.BufferGeometryUtils: .mergeGeometries() failed with geometry at index "+r+". Make sure all geometries have the same number of attributes."),null;if(d!==u.morphTargetsRelative)return console.error("THREE.BufferGeometryUtils: .mergeGeometries() failed with geometry at index "+r+". .morphTargetsRelative must be consistent throughout all geometries."),null;for(const a in u.morphAttributes){if(!l.has(a))return console.error("THREE.BufferGeometryUtils: .mergeGeometries() failed with geometry at index "+r+".  .morphAttributes must be consistent throughout all geometries."),null;s[a]===void 0&&(s[a]=[]),s[a].push(u.morphAttributes[a])}if(n){let a;if(t)a=u.index.count;else if(u.attributes.position!==void 0)a=u.attributes.position.count;else return console.error("THREE.BufferGeometryUtils: .mergeGeometries() failed with geometry at index "+r+". The geometry must have either an index or a position attribute"),null;o.addGroup(h,a,r),h+=a}}if(t){let r=0;const u=[];for(let f=0;f<i.length;++f){const a=i[f].index;for(let p=0;p<a.count;++p)u.push(a.getX(p)+r);r+=i[f].attributes.position.count}o.setIndex(u)}for(const r in c){const u=q(c[r]);if(!u)return console.error("THREE.BufferGeometryUtils: .mergeGeometries() failed while trying to merge the "+r+" attribute."),null;o.setAttribute(r,u)}for(const r in s){const u=s[r][0].length;if(u===0)break;o.morphAttributes=o.morphAttributes||{},o.morphAttributes[r]=[];for(let f=0;f<u;++f){const a=[];for(let v=0;v<s[r].length;++v)a.push(s[r][v][f]);const p=q(a);if(!p)return console.error("THREE.BufferGeometryUtils: .mergeGeometries() failed while trying to merge the "+r+" morphAttribute."),null;o.morphAttributes[r].push(p)}}return o}function q(i){let n,t,e,l=-1,c=0;for(let h=0;h<i.length;++h){const r=i[h];if(r.isInterleavedBufferAttribute)return console.error("THREE.BufferGeometryUtils: .mergeAttributes() failed. InterleavedBufferAttributes are not supported."),null;if(n===void 0&&(n=r.array.constructor),n!==r.array.constructor)return console.error("THREE.BufferGeometryUtils: .mergeAttributes() failed. BufferAttribute.array must be of consistent array types across matching attributes."),null;if(t===void 0&&(t=r.itemSize),t!==r.itemSize)return console.error("THREE.BufferGeometryUtils: .mergeAttributes() failed. BufferAttribute.itemSize must be consistent across matching attributes."),null;if(e===void 0&&(e=r.normalized),e!==r.normalized)return console.error("THREE.BufferGeometryUtils: .mergeAttributes() failed. BufferAttribute.normalized must be consistent across matching attributes."),null;if(l===-1&&(l=r.gpuType),l!==r.gpuType)return console.error("THREE.BufferGeometryUtils: .mergeAttributes() failed. BufferAttribute.gpuType must be consistent across matching attributes."),null;c+=r.array.length}const s=new n(c);let d=0;for(let h=0;h<i.length;++h)s.set(i[h].array,d),d+=i[h].array.length;const o=new we(s,t,e);return l!==void 0&&(o.gpuType=l),o}const Ce={namespace:"source-engine.bsp",priority:2,createViewer:async(i,n)=>{if(i.type==V.Directory){const t=i.old;if(!t||t.type==V.Directory)throw new Error("Tried to create bsp viewer with transformed viewer that has no file.");const e=new X(await t.blob());await e.readHeader();const l=F.root(i),c=l&&l!=i?await Ue(l,[i]):i,{renderer:s,scene:d}=de.createRendererWithControls(),o=s.domElement;o.style.width="100vw",o.style.height="100vh",n.appendChild(o);const h=await e.getVertices(),r=await e.getEdges(),u=await e.getSurfEdges(),f=await e.getFaces(),a=await e.getTexInfos(),p=await e.getTexDatas(),v=await e.getDispInfos(),Q=await e.getDispVerts(),Y=await e.getTexDataStrings(),O=await Promise.all(Y.map(async g=>{g=`materials/${g.toLowerCase()}`,g.endsWith(".vmt")||(g+=".vmt");const b=await F.getDeep(c,g);if(!b||b.type!=V.File)return console.warn(`Could not find material file "${g}"`),null;const T=new Se(b);try{return await T.getShader(c)}catch(B){return console.error(B),console.warn(`Failed to get shader "${g}"`),null}}));console.log(c);const K=O.map(()=>[]);for(const g of f){const b=a[g.texInfo],T=p[b.texData],B=T.reflectivity;let y=[];for(let m=0;m<g.numEdges;m++){const w=u[g.firstEdge+m],A=r[Math.abs(w)],$=h[A[w<0?1:0]];y.push($)}let R=[];if(g.dispInfo==-1)for(let m=0;m<y.length-2;m++)R.push(m+2,m+1,0);else{if(y.length!=4)throw new Error("BSP Invalid displacement.");const m=v[g.dispInfo],w=Math.pow(2,m.power),A=y.findIndex(N=>m.startPosition.distanceTo(N)<.1),$=y[(A+0)%4],ae=y[(A+1)%4],oe=y[(A+2)%4],ue=y[(A+3)%4];y=[];for(let N=0;N<w+1;N++)for(let x=0;x<w+1;x++){const S=N/w,C=x/w,L=N*(w+1)+x,G=Q[m.dispVertStart+L],W=new U().lerpVectors(new U().lerpVectors($,ae,S),new U().lerpVectors(ue,oe,S),C);W.add(new U().copy(G.vec).multiplyScalar(G.dist)),y.push(W)}for(let N=0;N<w;N++)for(let x=0;x<w;x++){const S=N*(w+1)+x,C=(N+1)*(w+1)+x,L=(N+1)*(w+1)+x+1,G=N*(w+1)+x+1;R.push(L,C,S,G,L,S)}}const te=new U(b.textureVecs[0][0],b.textureVecs[0][1],b.textureVecs[0][2]),re=new U(b.textureVecs[1][0],b.textureVecs[1][1],b.textureVecs[1][2]),se=b.textureVecs[0][3],ie=b.textureVecs[1][3],ne=y.map(m=>new ye((te.dot(m)+se)/T.width,(re.dot(m)+ie)/T.height)),D=new J;D.setAttribute("position",new H(y.map(m=>m.toArray()).flat(),3)),D.setAttribute("color",new H(y.map(()=>B.toArray()).flat(),3)),D.setIndex(R),D.setAttribute("uv",new H(ne.map(m=>m.toArray()).flat(),2)),K[T.nameStringTableID].push(D)}const ee=K.map((g,b)=>{if(g.length==0)return null;const T=O[b],B=Fe(g);return new Ne(B,T??new xe({vertexColors:!0}))}).filter(he.isNotNull),k=new Ee;k.add(...ee),k.rotateX(-Math.PI/2),d.add(k)}else throw new Error("Tried to create bsp viewer with file.")},transform:async i=>{if(i.type!=V.File)throw new Error("Tried to create bsp pakfile archive viewer with invalid entry type.");const n=new X(await i.blob());await n.readHeader();const t=await n.getPakFile(i.name,i.parent);if(!t)return null;const e=t;return e.old=i,e},getIcon:async()=>"/asset-viewer/bootstrap-icons/boxes.svg"};export{Ce as default};
