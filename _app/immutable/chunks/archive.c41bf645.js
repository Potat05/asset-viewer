var y=Object.defineProperty;var m=(i,t,e)=>t in i?y(i,t,{enumerable:!0,configurable:!0,writable:!0,value:e}):i[t]=e;var s=(i,t,e)=>(m(i,typeof t!="symbol"?t+"":t,e),e);import{D as v,a as c,f as b}from"./2.5f3b6209.js";import{p as E}from"./pako.esm.29d98458.js";import{D as g}from"./depickle.7b50937e.js";const A=34,R="RPA-3.0";class D{constructor(t,e,r,o){s(this,"type",b.File);s(this,"viewer",null);s(this,"name");s(this,"parent");s(this,"_blob");s(this,"sections");this._blob=t,this.sections=e,this.name=r,this.parent=o}async blob(){return new Blob(this.sections.map(t=>this._blob.slice(t.offset,t.offset+t.length)))}async buffer(){return await(await this.blob()).arrayBuffer()}}class H extends v{constructor(e){super();s(this,"blob");s(this,"blobPointer",0);s(this,"key",-1);this.blob=e}get blobLength(){return this.blob.size}get blobEof(){return this.blobPointer>=this.blobLength}get blobDataLeft(){return this.blobLength-this.blobPointer}getSlice(e,r=this.blobPointer){this.blobPointer=r;const o=this.blob.slice(this.blobPointer,this.blobPointer+e);return this.blobPointer+=e,o}async load(e,r=this.blobPointer){this.loadData(await this.getSlice(e,r).arrayBuffer())}decodeWithKey(e){return e<=4294967295?e^this.key:Number(BigInt(e)^BigInt(this.key))}async readHeader(){await this.load(A);const e=this.readString(this.dataLeft);if(!e.endsWith(`
`))throw new Error("ArchiveReader.readHeader: Archive header does not end with newline.");const r=e.split(" ");if(r.length!=3)throw new Error("ArchiveReader.readHeader: Invalid header.");if(r[0]!=R)throw new Error(`ArchiveReader.readHeader: Signature does not match. got: ${r[0]} expected: ${r[1]}`);const o=Number.parseInt(r[1],16);if(Number.isNaN(o))throw new Error("ArchiveReader.readHeader: Index offset is invalid.");if(this.key=Number.parseInt(r[2],16),Number.isNaN(this.key))throw new Error("ArchiveReader.readHeader: Key is invalid.");return o}async readArchive(){const e=await this.readHeader();this.blobPointer=e,await this.load(this.blobDataLeft);const r=this.buffer,o=E.inflate(r),d=g.depickle(o,{downcastLongs:!0}),a=new c.fsDirectory_Container("UNSET",null),f=d[0];for(const[n,p]of Object.entries(f)){const w=p.map(l=>({offset:this.decodeWithKey(l[0]),length:this.decodeWithKey(l[1])})),h=n.split("/").pop();if(h==null)throw new Error("Catastrophic error that should never happen.");const u=new D(this.blob,w,h,null);await c.setDeep(a,n,u)}return a}}const _={namespace:"renpy.archive",priority:10,transform:async i=>{if(i.type!=b.File)throw new Error("Tried to create renpy archive viewer with invalid entry type.");const e=await new H(await i.blob()).readArchive();return e.name=i.name,e.parent=i.parent,e}};export{_ as default};
