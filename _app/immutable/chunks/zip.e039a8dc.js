var M=Object.defineProperty;var v=(t,i,r)=>i in t?M(t,i,{enumerable:!0,configurable:!0,writable:!0,value:r}):t[i]=r;var a=(t,i,r)=>(v(t,typeof i!="symbol"?i+"":i,r),r);import{B as L}from"./BlobReader.433f7ad9.js";import{U as N,a as z,f as _,N as k,D as A}from"./2.1e08a865.js";import{i as R}from"./pako.esm.29d98458.js";class E{constructor(i){a(this,"data");a(this,"pos");this.data=new Uint8Array(N.getBuffer(i)),this.pos=0}readByte(){return this.data[this.pos++]}}class Z{constructor(i,r){a(this,"windowBuffer");a(this,"pos",0);a(this,"streamPos",0);a(this,"outputPos",0);this.windowSize=i,this.outputBuffer=r,this.windowBuffer=new Uint8Array(this.windowSize)}flush(){let i=this.pos-this.streamPos;i!==0&&(this.outputBuffer.set(this.windowBuffer.subarray(0,i),this.outputPos),this.outputPos+=i,this.pos>=this.windowSize&&(this.pos=0),this.streamPos=this.pos)}copyBlock(i,r){let s=this.pos-i-1;for(s<0&&(s+=this.windowSize);r--;)s>=this.windowSize&&(s=0),this.windowBuffer[this.pos++]=this.windowBuffer[s++],this.pos>=this.windowSize&&this.flush()}putByte(i){this.windowBuffer[this.pos++]=i,this.pos>=this.windowSize&&this.flush()}getByte(i){let r=this.pos-i-1;return r<0&&(r+=this.windowSize),this.windowBuffer[r]}}class I{constructor(i){a(this,"code",0);a(this,"range",-1);this.stream=i;for(let r=0;r<5;r++)this.code=this.code<<8|this.stream.readByte()}decodeDirectBits(i){var r=0,s;for(let e=0;e<i;e++)this.range>>>=1,s=this.code-this.range>>>31,this.code-=this.range&s-1,r=r<<1|1-s,this.range&4278190080||(this.code=this.code<<8|this.stream.readByte(),this.range<<=8);return r}decodeBit(i,r){var s=i[r],e=(this.range>>>11)*s;return(this.code^2147483648)<(e^2147483648)?(this.range=e,i[r]+=2048-s>>>5,this.range&4278190080||(this.code=this.code<<8|this.stream.readByte(),this.range<<=8),0):(this.range-=e,this.code-=e,i[r]-=s>>>5,this.range&4278190080||(this.code=this.code<<8|this.stream.readByte(),this.range<<=8),1)}}function b(t){return N.initArray(t,()=>1024)}class g{constructor(i){a(this,"models");this.numBitLevels=i,this.models=b(1<<this.numBitLevels)}decode(i){for(var r=1,s=this.numBitLevels;s--;)r=r<<1|i.decodeBit(this.models,r);return r-(1<<this.numBitLevels)}reverseDecode(i){for(var r=1,s=0,e=0,d;e<this.numBitLevels;++e)d=i.decodeBit(this.models,r),r=r<<1|d,s|=d<<e;return s}}function x(t,i,r,s){for(var e=1,d=0,o=0,n;o<s;++o)n=r.decodeBit(t,i+e),e=e<<1|n,d|=n<<o;return d}class D{constructor(i){a(this,"choice",b(2));a(this,"lowCoder");a(this,"midCoder");a(this,"highCoder",new g(8));this.numPosStates=i,this.lowCoder=N.initArray(this.numPosStates,()=>new g(3)),this.midCoder=N.initArray(this.numPosStates,()=>new g(3))}decode(i,r){return i.decodeBit(this.choice,0)===0?this.lowCoder[r].decode(i):i.decodeBit(this.choice,1)===0?8+this.midCoder[r].decode(i):16+this.highCoder.decode(i)}}class T{constructor(){a(this,"decoders",b(768))}decodeNormal(i){let r=1;do r=r<<1|i.decodeBit(this.decoders,r);while(r<256);return r&255}decodeWithMatchByte(i,r){let s=1,e,d;do if(e=r>>7&1,r<<=1,d=i.decodeBit(this.decoders,(1+e<<8)+s),s=s<<1|d,e!==d){for(;s<256;)s=s<<1|i.decodeBit(this.decoders,s);break}while(s<256);return s&255}}class F{constructor(i,r){a(this,"posMask",0);a(this,"coders");this.numPosBits=i,this.numPrevBits=r,this.posMask=(1<<this.numPosBits)-1;const s=1<<this.numPrevBits+this.numPosBits;this.coders=N.initArray(s,()=>new T)}getDecoder(i,r){return this.coders[((i&this.posMask)<<this.numPrevBits)+((r&255)>>>8-this.numPrevBits)]}}class G{constructor(i){a(this,"isMatchDecoders",b(192));a(this,"isRep0LongDecoders",b(192));a(this,"isRepDecoders",b(12));a(this,"isRepG0Decoders",b(12));a(this,"isRepG1Decoders",b(12));a(this,"isRepG2Decoders",b(12));a(this,"posDecoders",b(114));a(this,"posSlotDecoder",N.initArray(4,()=>new g(6)));a(this,"posAlignDecoder",new g(4));a(this,"lenDecoder");a(this,"repLenDecoder");a(this,"literalDecoder");a(this,"dictionarySize",-1);a(this,"dictionarySizeCheck",-1);a(this,"posStateMask",0);if(this.dictionarySize=i.dictionarySize,this.dictionarySize==0)throw new Error("LZMA decoder initialized with invalid dictionary size.");this.dictionarySizeCheck=Math.max(this.dictionarySize,1);const r=i.lc,s=i.lp,e=i.pb,d=1<<e;if(!(r<=8&&s<=4&&e<=4))throw new Error("LZMA decoder initialized with invalid properties.");this.literalDecoder=new F(s,r),this.lenDecoder=new D(d),this.repLenDecoder=new D(d),this.posStateMask=d-1}decodeBody(i,r,s){let e=0,d=0,o=0,n=0,c=0,u=0,l=0,w,U,f,p,m,B;const h=new I(i);if(r.byteLength<s)throw new Error("LZMA decoder read body with invalid size.");const y=new Z(Math.max(this.dictionarySizeCheck,4096),r);for(;s<0||u<s;)if(w=u&this.posStateMask,h.decodeBit(this.isMatchDecoders,(e<<4)+w)===0)U=this.literalDecoder.getDecoder(u++,l),e>=7?l=U.decodeWithMatchByte(h,y.getByte(d)):l=U.decodeNormal(h),y.putByte(l),e=e<4?0:e-(e<10?3:6);else{if(h.decodeBit(this.isRepDecoders,e)===1)f=0,h.decodeBit(this.isRepG0Decoders,e)===0?h.decodeBit(this.isRep0LongDecoders,(e<<4)+w)===0&&(e=e<7?9:11,f=1):(h.decodeBit(this.isRepG1Decoders,e)===0?p=o:(h.decodeBit(this.isRepG2Decoders,e)===0?p=n:(p=c,c=n),n=o),o=d,d=p),f===0&&(f=2+this.repLenDecoder.decode(h,w),e=e<7?8:11);else if(c=n,n=o,o=d,f=2+this.lenDecoder.decode(h,w),e=e<7?7:10,m=this.posSlotDecoder[f<=5?f-2:3].decode(h),m>=4){if(B=(m>>1)-1,d=(2|m&1)<<B,m<14)d+=x(this.posDecoders,d-m-1,h,B);else if(d+=h.decodeDirectBits(B-4)<<4,d+=this.posAlignDecoder.reverseDecode(h),d<0){if(d===-1)break;return!1}}else d=m;if(d>=u||d>=this.dictionarySizeCheck)return!1;y.copyBlock(d,f),u+=f,l=y.getByte(0)}return y.flush(),!0}}function $(t){const i=new DataView(N.getBuffer(t));let r=i.getUint8(0);const s=r%9;r=~~(r/9);const e=r%5,d=~~(r/5),o=i.getUint32(1,!0);return{lc:s,lp:e,pb:d,dictionarySize:o}}function K(t,i,r){const s=new E(t),e=new Uint8Array(r);if(!new G(i).decodeBody(s,e,r))throw new Error("LZMA failed decompressing.");return e.buffer}var P=(t=>(t[t.none=0]="none",t[t.shrunk=1]="shrunk",t[t.reduced_1=2]="reduced_1",t[t.reduced_2=3]="reduced_2",t[t.reduced_3=4]="reduced_3",t[t.reduced_4=5]="reduced_4",t[t.imploded=6]="imploded",t[t.deflated=8]="deflated",t[t.enhanced_deflated=9]="enhanced_deflated",t[t.pkware_dcl_imploded=10]="pkware_dcl_imploded",t[t.bzip2=12]="bzip2",t[t.lzma=14]="lzma",t[t.ibm_terse=18]="ibm_terse",t[t.ibm_lz77_z=19]="ibm_lz77_z",t[t.zstandard=93]="zstandard",t[t.mp3=94]="mp3",t[t.xz=95]="xz",t[t.jpeg=96]="jpeg",t[t.wavpack=97]="wavpack",t[t.ppmd=98]="ppmd",t[t.aex_encryption_marker=99]="aex_encryption_marker",t))(P||{});class S{constructor(i,r,s,e=null){a(this,"viewer",null);a(this,"type",_.File);a(this,"name");a(this,"parent");a(this,"zip");a(this,"options");a(this,"loadedBlob",null);this.zip=i,this.options=r,this.name=s,this.parent=e}async blob(){if(this.loadedBlob!=null)return this.loadedBlob;let i,r,s,e;if(this.options.type=="fileheader")i=this.options.compressionMethod,r=this.options.offset,s=this.options.compressedSize,e=this.options.uncompressedSize;else if(this.options.type=="centralfileheader"){const o=new L(this.zip);await o.load(30,this.options.offsetToLocalHeader),o.assertMagic("PK"),o.assertMagic(1027,"Uint16"),o.readNumber("Uint16"),o.readNumber("Uint16"),i=o.readNumber("Uint16"),o.readNumber("Uint32"),o.readNumber("Uint32"),s=o.readNumber("Uint32"),e=o.readNumber("Uint32");const n=o.readNumber("Uint16"),c=o.readNumber("Uint16");await o.load(n+c),o.readString(n,"utf-8"),o.readBuffer(c),r=o.blobPointer}else throw new Error("Zip file invalid options.");i!=0&&console.debug(`Decompressing file ${this.name} with ${P[i]??k.hex(i,2)} compression method`);const d=this.zip.slice(r,r+s);switch(i){case 0:{this.loadedBlob=d;break}case 8:{const o=await d.arrayBuffer(),n=R(o);this.loadedBlob=new Blob([n]);break}case 14:{const o=await d.arrayBuffer(),n=new A(o);n.readNumber("Uint8"),n.readNumber("Uint8");const c=n.readNumber("Uint16"),u=n.readBuffer(c),l=K(n.readBuffer(n.dataLeft),$(u),e);this.loadedBlob=new Blob([l]);break}default:throw new Error("Unknown zip file compression method.")}if(this.loadedBlob==null)throw new Error("Could not decompress zip file.");return this.loadedBlob}async buffer(){return await(await this.blob()).arrayBuffer()}}async function O(t){const s=[{start:Math.max(0,t.size-128),end:t.size},{start:Math.max(0,t.size-65558),end:t.size}],e=19280|1541<<16;for(const d of s){const o=t.slice(d.start,d.end),n=new DataView(await o.arrayBuffer());for(let c=n.byteLength-4;c>0;c--)if(n.getUint32(c,!0)==e)return t.size-(d.end-d.start)+c}return-1}async function X(t,i,r,s=!1){const e=new L(t),d=new z.fsDirectory_Container(i,r),o=s?c=>c.toLowerCase():c=>c,n=await O(t);if(n==-1)for(console.warn("Reading ZIP file without central directory.");!e.blobEof;){if(await e.load(4),!e.magic("PK"))return console.warn(`Invalid ZIP section type header. at ${e.blobPointer-2}`),d;const c=e.readNumber("Uint16");switch(c){case 513:{await e.load(42),e.readNumber("Uint16"),e.readNumber("Uint16"),e.readNumber("Uint16"),e.readNumber("Uint16"),e.readNumber("Uint32"),e.readNumber("Uint32"),e.readNumber("Uint32"),e.readNumber("Uint32");const u=e.readNumber("Uint16"),l=e.readNumber("Uint16"),w=e.readNumber("Uint16");e.readNumber("Uint16"),e.readNumber("Uint16"),e.readNumber("Uint32"),e.readNumber("Uint32"),await e.load(u+l+w),o(e.readString(u,"utf-8")),e.readBuffer(l),e.readString(w,"utf-8");break}case 1027:{await e.load(26),e.readNumber("Uint16"),e.readNumber("Uint16");const u=e.readNumber("Uint16");e.readNumber("Uint32"),e.readNumber("Uint32");const l=e.readNumber("Uint32"),w=e.readNumber("Uint32"),U=e.readNumber("Uint16"),f=e.readNumber("Uint16");await e.load(U+f);const p=o(e.readString(U,"utf-8"));e.readBuffer(f),e.blobPointer;const m=p.split("/").pop();if(m==null)throw new Error("Failed to read filename in zip file.");if(l>0){const B=new S(t,{type:"fileheader",compressionMethod:u,offset:e.blobPointer,compressedSize:l,uncompressedSize:w},m);await z.setDeep(d,p,B)}e.blobPointer+=l;break}case 2055:{e.blobPointer+=12;break}case 1541:return d;default:return console.warn(`Invalid ZIP section type. ${c} at ${e.blobPointer-2}`),d}}else{await e.load(22,n),e.assertMagic("PK"),e.assertMagic(1541,"Uint16"),e.readNumber("Uint16"),e.readNumber("Uint16"),e.readNumber("Uint16"),e.readNumber("Uint16");const c=e.readNumber("Uint32"),u=e.readNumber("Uint32"),l=e.readNumber("Uint16");for(await e.load(l),e.readString(e.dataLeft),await e.load(c,u);!e.eof;){e.assertMagic("PK"),e.assertMagic(513,"Uint16"),e.readNumber("Uint16"),e.readNumber("Uint16"),e.readNumber("Uint16"),e.readNumber("Uint16"),e.readNumber("Uint32"),e.readNumber("Uint32");const w=e.readNumber("Uint32");e.readNumber("Uint32");const U=e.readNumber("Uint16"),f=e.readNumber("Uint16"),p=e.readNumber("Uint16");e.readNumber("Uint16"),e.readNumber("Uint16"),e.readNumber("Uint32");const m=e.readNumber("Uint32"),B=o(e.readString(U,"utf-8"));e.readBuffer(f),e.readString(p,"utf-8");const h=B.split("/").pop();if(h==null)throw new Error("Failed to read filename in zip file.");if(w>0){const y=new S(t,{type:"centralfileheader",offsetToLocalHeader:m},h);await z.setDeep(d,B,y)}}}return d}export{K as a,$ as d,X as r};
