var y=Object.defineProperty;var m=(t,r,e)=>r in t?y(t,r,{enumerable:!0,configurable:!0,writable:!0,value:e}):t[r]=e;var s=(t,r,e)=>(m(t,typeof r!="symbol"?r+"":r,e),e);import{D as v,a as d,f as n}from"./2.ec27719f.js";import{p as E}from"./pako.esm.29d98458.js";import{D as g}from"./depickle.72866d05.js";const A=34,R="RPA-3.0";class D{constructor(r,e,i,a){s(this,"type",n.File);s(this,"viewer",null);s(this,"name");s(this,"parent");s(this,"_blob");s(this,"sections");this._blob=r,this.sections=e,this.name=i,this.parent=a}async blob(){return new Blob(this.sections.map(r=>this._blob.slice(r.offset,r.offset+r.length)))}async buffer(){return await(await this.blob()).arrayBuffer()}}class H extends v{constructor(e){super();s(this,"blob");s(this,"blobPointer",0);s(this,"key",-1);this.blob=e}get blobLength(){return this.blob.size}get blobEof(){return this.blobPointer>=this.blobLength}get blobDataLeft(){return this.blobLength-this.blobPointer}getSlice(e,i=this.blobPointer){this.blobPointer=i;const a=this.blob.slice(this.blobPointer,this.blobPointer+e);return this.blobPointer+=e,a}async load(e,i=this.blobPointer){this.loadData(await this.getSlice(e,i).arrayBuffer())}decodeWithKey(e){return e<=4294967295?e^this.key:Number(BigInt(e)^BigInt(this.key))}async readHeader(){await this.load(A);const e=this.readString(this.dataLeft);if(!e.endsWith(`
`))throw new Error("ArchiveReader.readHeader: Archive header does not end with newline.");const i=e.split(" ");if(i.length!=3)throw new Error("ArchiveReader.readHeader: Invalid header.");if(i[0]!=R)throw new Error(`ArchiveReader.readHeader: Signature does not match. got: ${i[0]} expected: ${i[1]}`);const a=Number.parseInt(i[1],16);if(Number.isNaN(a))throw new Error("ArchiveReader.readHeader: Index offset is invalid.");if(this.key=Number.parseInt(i[2],16),Number.isNaN(this.key))throw new Error("ArchiveReader.readHeader: Key is invalid.");return a}async readArchive(){const e=await this.readHeader();this.blobPointer=e,await this.load(this.blobDataLeft);const i=this.buffer,a=E.inflate(i),b=g.depickle(a,{downcastLongs:!0}),o=new d.fsDirectory_Container("UNSET",null),f=b[0];for(const[h,p]of Object.entries(f)){const w=p.map(c=>({offset:this.decodeWithKey(c[0]),length:this.decodeWithKey(c[1])})),l=h.split("/").pop();if(l==null)throw new Error("Catastrophic error that should never happen.");const u=new D(this.blob,w,l,null);await d.setDeep(o,h,u)}return o}}const _={namespace:"renpy.archive",priority:10,isValid:async t=>t.type==n.File&&t.name.endsWith(".rpa"),transform:async t=>{if(t.type!=n.File)throw new Error("Tried to create renpy archive viewer with invalid entry type.");const e=await new H(await t.blob()).readArchive();return e.name=t.name,e.parent=t.parent,e}};export{_ as default};
